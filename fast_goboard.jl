module FAST_GOBOARD

export other, player, point, row, col, neighbors, area, Move, play, pass_turn, resign, GoString, remove_liberty, add_liberty, merged_with, num_liberties, __eq__, Board, create_board, is_on_grid, get_go_string, get_stone, place_stone, hash, GameState, next_player, startofgame, last_move, apply_move, apply_move!, start_new_game, is_over, is_move_self_capture, situation, does_move_violate_ko, is_valid_move, legal_moves, get_winner, empty_territories, area_scoring, area_scoring_graphical, print_move, print_board, is_point_an_eye, is_atari_move, save_from_atari, possible_captures, cut1_pattern, cut2_pattern, hane_pattern, boundary_pattern

#include("C:\\Users\\sebas\\AppData\\Local\\JuliaPro-0.6.2.2\\dlgo\\gotypes.jl")


import Base.hash

############################################################################
#                           Zobrist Hashes
############################################################################

global_num_rows=19;
global_num_cols=19;

function generate_rand_position_code_table(num_rows::Int,num_cols::Int)

    # This function generates hash values (of type UInt64) for every possible board position consisting of atmost one
    # stone (including the empty board) encoded by (-1,-1,:nothing).


    MAX63=0x7fffffffffffffff;
    empty_board=xor(MAX63,MAX63);
    table=Dict([(-1,-1,:nothing)=>empty_board])


    for row in 1:num_rows
        for col in 1:num_cols
            for color in [:black,:white]
                code=rand(1:MAX63);


                push!(table,(row,col,color)=>code);
            end
        end
    end

    return table;
end

# The hash values generated by the function above are stored in the lookup-table HASH_CODE.
# The hash values of arbitrary board positions are generated by recursively applying the hash values of single
# stones (stored in HASH_CODE) via xor.

HASH_CODE=generate_rand_position_code_table(global_num_rows,global_num_cols)::Dict{Tuple{Int64,Int64,Symbol},UInt64};



#################################################################################
#                           Player functions
#################################################################################


function other(player::Symbol)
    #returns the color of the other player as a symbol

    if (player == :black)
        return :white;
    elseif (player == :white)
        return :black;
    else
        return :nothing;
    end

end



function player(player::Symbol)
    #returns the color of player as a string

    if (player == :black)
        return "black";
    elseif (player == :white)
        return "white";
    else
        return "nothing";
    end

end



#################################################################################
#                           Point functions
#################################################################################


function point(row::Int64,col::Int64)
    return (row,col);
end


function row(point::Tuple{Int64,Int64})
    return point[1];
end


function col(point::Tuple{Int64,Int64})
    return point[2];
end

function neighbors(point::Tuple{Int64,Int64})
    # Returns the 4 neighbors of the position point (upper, lower, left, right) without checking wether these
    # positions are on the board

        return [(row(point)-1,col(point)), (row(point)+1,col(point)),
                (row(point),col(point)-1), (row(point),col(point)+1)];
end

function area(point::Tuple{Int64,Int64})
    # Returns the 8 positions surrounding the position point without checking wether these positions are on the board

        return [(row(point)-1,col(point)-1), (row(point)-1,col(point)),
                (row(point)-1,col(point)+1), (row(point),col(point)-1),
                (row(point),col(point)+1), (row(point)+1,col(point)-1),
                (row(point)+1,col(point)), (row(point)+1,col(point)+1)];
end



############################################################################
#                               Move Class
############################################################################
struct Move
    point::Tuple{Int64,Int64};
    is_play::Bool;
    is_pass::Bool;
    is_resign::Bool;
end

function play(p::Tuple{Int64,Int64})
    return Move(p,true,false,false);
end

function pass_turn()
    return Move(point(-1,-1),false,true,false);
end

function resign()
    return Move(point(-1,-1),false,false,true);
end




###############################################################################
#                           GoString Class
###############################################################################

struct GoString
    # Go strings are sets of connected stones (i.e. for two stones in the set there is a path made up entirley
    # by stones of this set that connects the two stones. In each step this path jumps to one of the neighbors)
    # of the same color. We represent them by the struct GoString, which not only stores the color and the stones,
    # that make up the Go string, but also the liberties, which are the empty board positions that are neighbors
    # of one of the stones of the Go string.

    color::Symbol;
    stones::Set{Tuple{Int64,Int64}};
    liberties::Set{Tuple{Int64,Int64}};
end


function remove_liberty(gostring::GoString,p::Tuple{Int64,Int64})
        pop!(gostring.liberties,p);
end


function add_liberty(gostring::GoString,p::Tuple{Int64,Int64})
    push!(gostring.liberties,p);
end


function merged_with(gostring1::GoString,gostring2::GoString)
    # This function merges two Go strings into one

    @assert(gostring1.color==gostring2.color);

    combined_stones=union(gostring1.stones,gostring2.stones);

    return GoString(gostring1.color,combined_stones,setdiff(union(gostring1.liberties,gostring2.liberties),combined_stones));
end


function num_liberties(gostring::GoString)
    # Returns the number of liberties of the the Go string

    return length(gostring.liberties);
end

function __eq__(gostring1::GoString,gostring2::GoString)
    return ((gostring1.color==gostring2.color)&&(gostring1.stones==gostring2.stones)&&(gostring1.liberties==gostring2.liberties))

end


#############################################################################
#                           Board Class
#############################################################################

struct Board
    num_rows::Int64; #number of rows
    num_cols::Int64; #number of columns of the Go board
    _grid::Dict{Tuple{Int64,Int64},GoString}; #dictionary that stores strings of stones
    _hash::Vector{UInt64}; # Hash value of the board configuration. It is stored in a one dimensional array to
                           # keep the values mutable while the Board is an immutable struct (for better performance)
end


function create_board(num_rows::Int64,num_cols::Int64)
    @assert (num_rows<=global_num_rows) "num_rows>$global_num_rows\n"
    @assert (num_cols<=global_num_cols ) "num_cols>$global_num_cols\n"

    return Board(num_rows,num_cols,Dict([]),[HASH_CODE[(-1,-1,:nothing)]])
end


function is_on_grid(board::Board,point::Tuple{Int64,Int64})
    # Checks wether the tuple point is an actual position on the board

    return ((1<=row(point))&&(row(point)<=board.num_rows)&&(1<=col(point))&&(col(point)<=board.num_cols));
end


function get_go_string(board::Board,point::Tuple{Int64,Int64})
    # Returns the Go string that includes the stone on the board position point. A trivial Go string is returned
    # in the case that there is no matching Go string

    str=get(board._grid,point,GoString(:nothing,Set{Tuple{Int64,Int64}}(),Set{Tuple{Int64,Int64}}()));

    return str;
end


function get_stone(board::Board,point::Tuple{Int64,Int64})
    # Returns the color of the stone placed on point as a symbol

    str=get_go_string(board,point);

    return str.color;
end


function _remove_string(board::Board,str::GoString)
    for point in str.stones
        for neighbor in neighbors(point)
            neighbor_string=get_go_string(board,neighbor);
            if (neighbor_string.color==:nothing)
                continue;
            else
                add_liberty(neighbor_string,point);
            end
        end
        delete!(board._grid,point);

    board._hash[1]=xor(board._hash[1],HASH_CODE[row(point),col(point),str.color]);
    end
end




function place_stone(board::Board,player::Symbol,point::Tuple{Int64,Int64})
    @assert(is_on_grid(board,point));
    @assert(get_stone(board,point)==:nothing);

    adjacent_same_color=GoString[];
    adjacent_opposite_color=GoString[];
    liberties=Tuple{Int64,Int64}[];

    for neighbor in neighbors(point)

        if !(is_on_grid(board,neighbor))
            continue;
        end

        neighbor_string=get_go_string(board,neighbor);

       if neighbor_string.color==:nothing
            push!(liberties,neighbor);
        elseif neighbor_string.color==player
            if !(in(neighbor_string,adjacent_same_color))
                push!(adjacent_same_color,neighbor_string);
            end
        else
            if !(in(neighbor_string,adjacent_opposite_color))
                push!(adjacent_opposite_color,neighbor_string);
            end
        end
    end

    new_string=GoString(player,Set([point]),Set(liberties));

    for same_color_string in adjacent_same_color
        new_string=merged_with(new_string,same_color_string);
    end

    for new_string_point in new_string.stones
        board._grid[new_string_point]=new_string;
    end

    board._hash[1]=xor(board._hash[1],HASH_CODE[row(point),col(point),player]);

    for other_color_string in adjacent_opposite_color
        remove_liberty(other_color_string,point);
    end

    for other_color_string in adjacent_opposite_color
        if (num_liberties(other_color_string)==0)
            _remove_string(board,other_color_string);
        end
    end

end

function hash(board::Board)
    return board._hash[1];
end





#################################################################################
#                              Game State Class
#################################################################################

struct GameState
    # Struct to store the current gamestate.

    board::Board;
    next_player::Array{Symbol,1}; #stored as an array to make this field mutable while letting GameState remain immutable
    previous_states::Set{Tuple{Symbol,UInt64}}; #set of tuples of hash values of previous game states and the last player color (as a string)
    last_2_moves::Array{Move,1}; # array containing the last 2 moves.  last_2_moves[1]=last move   last_2_moves[2]=second last move
end



function next_player(state::GameState)
    return state.next_player[1];
end



function startofgame(state::GameState)
    return state.last_2_moves[1].point==(-100,-100);
end



function last_move(state::GameState)
    return state.last_2_moves[1];
end



function apply_move(state::GameState,player::Symbol,move::Move)
    # Creates a new state by playing a move

    @assert (player==next_player(state)) ["Argument player is not the next player!\n player: $(player.color) != next player: $(state.next_player.color)"];

    next_previous_states=deepcopy(state.previous_states)
    push!(next_previous_states,(next_player(state),hash(state.board)))

    if move.is_play
        next_board=deepcopy(state.board);
        place_stone(next_board,player,move.point);
    else
        next_board=state.board;
    end


    return GameState(next_board,[other(player)],next_previous_states,[move,state.last_2_moves[1]]);
end



function apply_move!(state::GameState,player::Symbol,move::Move)
    # Changes a state by playing a move

    @assert (player==next_player(state)) ["Argument player is not the next player!\n player: $(player) != next player: $(next_player(state))"];

    push!(state.previous_states,(next_player(state),hash(state.board)))

    if move.is_play
        place_stone(state.board,player,move.point);
    else
        next_board=state.board;
    end

    state.next_player[1]=other(player);
    state.last_2_moves[2]=state.last_2_moves[1];
    state.last_2_moves[1]=move;
end



function start_new_game(board_size)
    board=create_board(board_size,board_size);
    return GameState(board,[:black],Set{Tuple{Symbol,UInt64}}(),[Move((-100,-100),true,false,false),Move((-100,-100),true,false,false)]);
end



function is_over(state::GameState)
    if (state.last_2_moves[1].point==(-100,-100))
        return false;
    end

    if(state.last_2_moves[1].is_resign)
        return true;
    end

    if(state.last_2_moves[2].point==(-100,-100))
        return false;
    end

    return (state.last_2_moves[1].is_pass && state.last_2_moves[2].is_pass);
end



function is_move_self_capture(state::GameState,player::Symbol,move::Move)
    #checks whether a move is a self capture

    if !(move.is_play)
        return false;
    end
    @assert(is_on_grid(state.board,move.point));
    @assert(get_stone(state.board,move.point)==:nothing);


    for neighbor in neighbors(move.point)

        if !is_on_grid(state.board,neighbor)
            continue;
        else
            if get_stone(state.board,neighbor)==:nothing
                return false;
            end

            if (get_stone(state.board,neighbor)==player && num_liberties(get_go_string(state.board,neighbor))>1)
                return false;
            end

            if (get_stone(state.board,neighbor)==other(player) && num_liberties(get_go_string(state.board,neighbor))<=1)
                return false;
            end
        end

    end

    return true;

end



function situation(state::GameState)
    return (state.next_player,state.board);
end



function does_move_violate_ko(state::GameState,player::Symbol,move::Move)

    if !(move.is_play)
        return false;
    end

    @assert(is_on_grid(state.board,move.point));
    @assert(get_stone(state.board,move.point)==:nothing);

    hashvalue=hash(state.board);
    hashvalue=xor(hashvalue,HASH_CODE[row(move.point),col(move.point),player]);


    for neighbor in neighbors(move.point)

        if !is_on_grid(state.board,neighbor)
            continue;
        else

            if (get_stone(state.board,neighbor)==other(player) && num_liberties(get_go_string(state.board,neighbor))<=1)

                for point in get_go_string(state.board,neighbor).stones
                    hashvalue=xor(hashvalue,HASH_CODE[row(point),col(point),other(player)])
                end
            end
        end
    end

    return ((other(player),hashvalue) in state.previous_states);
end



function is_valid_move(state::GameState,move::Move)
    if is_over(state)
        return false;
    end

    if (move.is_pass || move.is_resign)
        return true;
    end

    return ((get_stone(state.board,move.point)==:nothing) &&
            !(is_move_self_capture(state,state.next_player[1],move)) &&
            !(does_move_violate_ko(state,state.next_player[1],move)))
end



function legal_moves(state::GameState)

    possible_moves=Move[];

    for row in 1:state.board.num_rows

        for col in 1:state.board.num_cols
            if  is_valid_move(state,Move((row,col),true,false,false))

                push!(possible_moves,Move((row,col),true,false,false));

            end
        end
    end

    return possible_moves;
end




function get_winner(state::GameState)
# returns winner by area scoring for random simulations

    score_white=0;
    score_black=0;

    #komi compensation
    score_white=6.5;

    neighbor_set=Set{Symbol}()


    for row in 1:state.board.num_rows
        for col in 1:state.board.num_cols

            stone=get_stone(state.board,point(row,col));

            if stone==:nothing
                empty_neighbor=false;
                for neighbor in neighbors(point(row,col))
                    if !(is_on_grid(state.board,neighbor))
                        continue;
                    end

                    if get_stone(state.board,neighbor)==:black
                        push!(neighbor_set,:black);
                    elseif get_stone(state.board,neighbor)==:white
                        push!(neighbor_set,:white);
                    end
                end

                if(neighbor_set==Set([:white]))
                    score_white+=1;
                elseif (neighbor_set==Set([:black]))
                    score_black+=1;
                end

                neighbor_set=Set{Symbol}();


            elseif stone==:black
                score_black+=1;
            else
                score_white+=1;
            end
        end
    end

    if score_black>score_white
        return [:black,score_black,score_white];
    else
        return [:white,score_black,score_white];
    end

end



function empty_territories(state::GameState)
    # Returns all territories made up of empty board position, i.e. all sets of connected empty nodes.
    # For each empty point on the board the territory it is a part of is determined by Breadth First Search
    #
    # The territories that we return are tuples of sets and symbols. The first component contains the nodes
    # that form the territory, the second component stores the color of stones by which they are surrounded
    # Hereby :black or :white means, that the territory is only surrounded by stones of that particular color,
    #        whereas :nothing means that the territory is surrounded by both or nothing (empty board)

    territories=Set{Tuple{Set{Tuple{Int64,Int64}},Symbol}}();
    count=0;

    for row in 1:state.board.num_rows,col in 1:state.board.num_cols

        color=:nothing;

        if (get_stone(state.board,point(row,col))!=:nothing)
            continue;
        end

        already_explored=false;

        for territory in territories
            if ((row,col) in territory[1])
                already_explored=true;
                break;
            end
        end

        if already_explored
            continue;
        end

        current_territory=Set{Tuple{Int64,Int64}}();
        stones_to_explore=Set([(row,col)]);
        surroundedby= Set{Symbol}();

        while length(stones_to_explore)>0

            point=pop!(stones_to_explore);

            push!(current_territory,point);

            for neighbor in neighbors(point)
                if  (is_on_grid(state.board,neighbor) && !(neighbor in current_territory))

                    if get_stone(state.board,neighbor)==:nothing
                        push!(stones_to_explore,neighbor);
                    elseif get_stone(state.board,neighbor)==:black
                        push!(surroundedby,:black);
                    else
                        push!(surroundedby,:white);
                    end
                end
            end

        end


        if ((:black in surroundedby) && !(:white in surroundedby))
            color=:black;
        end

        if ((:white in surroundedby) && !(:black in surroundedby))
            color=:white;
        end

        push!(territories,(current_territory,color));

    end

    return territories;
end



function area_scoring(state::GameState)
# returns winner+ score by area scoring

    score_white=0;
    score_black=0;

    #komi compensation
    score_white=6.5;

    # all points on the board are added to the score
    for gostring in Set(values(state.board._grid))
        if gostring.color==:black
            score_black+=length(gostring.stones);
        else
            score_white+=length(gostring.stones);
        end
    end

    # the empty nodes that are surrounded by stones are added to the score
    for territory in empty_territories(state)
        if territory[2]==:black
            score_black+=length(territory[1]);
        end
        if territory[2]==:white
            score_white+=length(territory[1]);
        end
    end

    # returning the winner + the scores
    if last_move(state).is_resign
        return [next_player(state),score_black,score_white];
    end

    if (score_black>score_white)
        return [:black,score_black,score_white];
    else
        return [:white,score_black,score_white];
    end

end



function area_scoring_graphical(state::GameState)
# returns winner+ score by area scoring

    score_white=0;
    score_black=0;

    #komi compensation
    score_white=6.5;

    neighbor_set=Set{Symbol}();
    scored_as=Dict([(j,k)=>"." for j=1:state.board.num_rows,k=1:state.board.num_cols]);

    default = Base.text_colors[:default];
    yel = Base.text_colors[:yellow];
    red = Base.text_colors[:red];

    "$(yel)w$(default)"


    # deriving the score
    # all points on the board are added to the score
    for gostring in Set(values(state.board._grid))
        if gostring.color==:black
            for point in gostring.stones
                score_black+=1;
                scored_as[point]="$(red)B$(default)";
            end
        else
            for point in gostring.stones
                score_white+=1;
                scored_as[point]="$(yel)W$(default)";
            end
        end
    end

    # the empty nodes that are surrounded by stones are added to the score
    for territory in empty_territories(state)
        if territory[2]==:black
            for point in territory[1]
                score_black+=1;
                scored_as[point]="$(red)b$(default)";
            end
        end
        if territory[2]==:white
            for point in territory[1]
                score_white+=1;
                scored_as[point]="$(yel)w$(default)";
            end
        end
    end

    # displaying the scored board

    for row in 1:state.board.num_rows

        disprow_stones="";
        disprow_score="";

        for col in 1:state.board.num_cols
            stone=get_stone(state.board,point(row,col));

            disprow_stones*="$(stone_to_char[stone])  ";
            disprow_score*="$(scored_as[row,col])  "
        end

        println("\n$row   $disprow_stones       $row   $disprow_score");
    end


    disprow_stones="";

    for col in 1:state.board.num_cols
        disprow_stones*="$(COLS[col])  ";
    end
    println("\n.   $disprow_stones       .   $disprow_stones\n");




    # returning the winner + the scores
    if last_move(state).is_resign
        return [next_player(state),score_black,score_white];
    end
    if (score_black>score_white)
        return [:black,score_black,score_white];
    else
        return [:white,score_black,score_white];
    end

end



#########################################################################################################################
#                                  Print board
#########################################################################################################################



COLS="ABCDEFGHJKLMNOPQRST";

#stone_to_char=Dict([nothing=>'.',"black"=>'x',"white"=>'o']);
stone_to_char=Dict([:nothing=>'.',:white=>'âšˆ',:black=>'O']);


function print_move(player::Symbol,move::Move)
    if (move.is_pass)
        move_str="passes";
    elseif (move.is_resign)
        move_str="resigns";
    elseif move.point==(-100,-100)
        move_str="no move"
    else
        move_str=string("(",COLS[col(move.point)],row(move.point),")");
    end

    println("\n $player: $move_str");
end



function print_board(board::Board)

    for row in 1:board.num_rows

        disprow="";

        for col in 1:board.num_cols
            stone=get_stone(board,point(row,col));

            disprow*="$(stone_to_char[stone])  ";
        end

        println("\n$row   $disprow");
    end


    disprow=""

    for col in 1:board.num_cols
        disprow*="$(COLS[col])  ";
    end
    println("\n.   $disprow\n");

end







################################################################################
#                       auxiliary functions
################################################################################



function is_point_an_eye(board::Board,point::Tuple{Int64,Int64},color::Symbol)
    if (get_stone(board,point)!=:nothing)
        return false;
    end

    for neighbor in neighbors(point)
        if is_on_grid(board,neighbor)
            if get_stone(board,neighbor)!=color
                return false;
            end
        end
    end

    friendly_corners=0;
    off_board_corners=0;
    corners=[(row(point)-1,col(point)-1),(row(point)-1,col(point)+1),(row(point)+1,col(point)-1),(row(point)+1,col(point)+1)];

    for corner in corners
        if is_on_grid(board,corner)
            if color==get_stone(board,corner)
                friendly_corners+=1;
            end
        else
            off_board_corners+=1;
        end
    end

    if off_board_corners>0
        return (off_board_corners+friendly_corners==4);
    end

    return (friendly_corners>=3)
end



function is_atari_move(state::GameState,point::Tuple{Int64,Int64},color::Symbol)

    str=GoString(:nothing,Set{Tuple{Int64,Int64}}(),Set{Tuple{Int64,Int64}}());

    if get_stone(state.board,point)!=:nothing
        return false;
    end
    if !(is_on_grid(state.board,point))
        return false;
    end

    for neighbor in neighbors(point)
        if !(is_on_grid(state.board,neighbor))
            continue;
        end

        str=get_go_string(state.board,neighbor);

        if (str.color==color  && (num_liberties(str)==2))
            return true;
        end
    end

    return false;
end

function is_atari_move(state::GameState,point::Tuple{Int64,Int64})
    return is_atari_move(state,point,next_player(state));
end




function save_from_atari(state::GameState)

    saving_stones=Tuple{Int64,Int64}[];

    if state.last_2_moves[1].point!=(-100,-100)
        if state.last_2_moves[1].is_play==true
            p=state.last_2_moves[1].point;

            for neighbor in neighbors(p)
                if (is_on_grid(state.board,neighbor) && (get_stone(state.board,neighbor)==next_player(state)))

                    str=get_go_string(state.board,neighbor);

                    if num_liberties(str)==1

                        pp=pop!(deepcopy(str.liberties));

                        if is_valid_move(state,Move(pp,true,false,false))
                            push!(saving_stones,pp);
                        end
                    end
                end
            end
        end
    end


    return saving_stones;
end



function possible_captures(state::GameState,player::Symbol)

    capturing_points=Set{Tuple{Int64,Int64}}();

    for str in Set(values(state.board._grid))
        if str.color==other(player)
            if num_liberties(str)==1
                pp=pop!(deepcopy(str.liberties));

                if is_valid_move(state,Move(pp,true,false,false))
                    capturing_points=union(capturing_points,str.liberties);
                end
            end
        end
    end

    return collect(capturing_points);
end



function hane_pattern(state::GameState,point::Tuple{Int64,Int64})

    row=point[1];
    col=point[2];

    for p in area(point)
        if !(is_on_grid(state.board,p))
            return false;
        end
    end

    a=get_stone(state.board,(row+1,col-1));
    b=get_stone(state.board,(row+1,col));
    c=get_stone(state.board,(row+1,col+1));
    d=get_stone(state.board,(row,col-1));
    e=get_stone(state.board,(row,col+1));
    f=get_stone(state.board,(row-1,col-1));
    g=get_stone(state.board,(row-1,col));
    h=get_stone(state.board,(row-1,col+1));



    t1=((c!=:nothing) && (b!=:nothing) && (c==a) && (c!=b) && (e==:nothing) && (d==:nothing));

    t2=((a!=:nothing) && (d!=:nothing) && (f==a) && (a!=d) && (b==:nothing) && (g==:nothing));

    t3=((f!=:nothing) && (g!=:nothing) && (f==h) && (f!=g) && (d==:nothing) && (e==:nothing));

    t4=((h!=:nothing) && (e!=:nothing) && (c==h) && (h!=e) && (g==:nothing) && (b==:nothing));



    T1=(t1 || t2 || t3 || t4);




    t1=((a!=:nothing) && (b!=:nothing) && (a!=b) && (c==:nothing) && (e==:nothing) && (d==:nothing) && (g==:nothing));

    t1= t1 || ((c!=:nothing) && (b!=:nothing) && (c!=b) && (a==:nothing) && (d==:nothing) && (e==:nothing) && (g==:nothing)) ;

    t2=((f!=:nothing) && (d!=:nothing) && (f!=d) && (a==:nothing) && (b==:nothing) && (e==:nothing) && (g==:nothing));

    t2= t2 || ((a!=:nothing) && (d!=:nothing) && (a!=d) && (f==:nothing) && (b==:nothing) && (g==:nothing) && (e==:nothing));

    t3=((c!=:nothing) && (e!=:nothing) && (c!=e) && (h==:nothing) && (b==:nothing) && (d==:nothing) && (g==:nothing));

    t3= t3 || ((h!=:nothing) && (e!=:nothing) && (h!=e) && (c==:nothing) && (b==:nothing) && (d==:nothing) && (g==:nothing));

    t4=((h!=:nothing) && (g!=:nothing) && (h!=g) && (f==:nothing) && (d==:nothing) && (e==:nothing) && (b==:nothing));

    t4= t4 || ((f!=:nothing) && (g!=:nothing) && (f!=g) && (h==:nothing) && (d==:nothing) && (e==:nothing) && (b==:nothing));


    T2=(t1 || t2 || t3 || t4);




    t1=((a!=:nothing) && (b!=:nothing) && (a==d) && (a!=b) && (g==:nothing) && (e==:nothing));

    t1= t1 || ((c!=:nothing) && (b!=:nothing) && (c==e) && (b!=c) && (d==:nothing) && (g==:nothing));

    t2=((f!=:nothing) && (d!=:nothing) && (f==g) && (d!=f) && (b==:nothing) && (e==:nothing));

    t2= t2 || ((a!=:nothing) && (d!=:nothing) && (a==b) && (d!=a) && (g==:nothing) && (e==:nothing));

    t3=((h!=:nothing) && (g!=:nothing) && (h==e) && (h!=g) && (d==:nothing) && (b==:nothing));

    t3= t3 || ((f!=:nothing) && (g!=:nothing) && (f==d) && (f!=g) && (e==:nothing) && (b==:nothing));

    t4=((c!=:nothing) && (e!=:nothing) && (c==b) && (c!=e) && (g==:nothing) && (d==:nothing));

    t4=t4 || ((h!=:nothing) && (e!=:nothing) && (h==g) && (h!=e) && (b==:nothing) && (d==:nothing));


    T3=(t1 || t2 || t3 || t4);



    t1=((next_player(state)==a) && (b!=:nothing) && (c==b) && (a!=b) && (d==:nothing) && (e==:nothing) && (g==:nothing));

    t1= t1 || ((next_player(state)==c) && (b!=:nothing) && (a==b) && (c!=b) && (d==:nothing) && (e==:nothing) && (g==:nothing));

    t2=((next_player(state)==f) && (d!=:nothing) && (a==d) && (f!=d) && (b==:nothing) && (e==:nothing) && (g==:nothing));

    t2= t2 || ((next_player(state)==a) && (d!=:nothing) && (f==d) && (a!=d) && (b==:nothing) && (e==:nothing) && (g==:nothing));

    t3=((next_player(state)==f) && (g!=:nothing) && (h==g) && (f!=g) && (d==:nothing) && (e==:nothing) && (b==:nothing));

    t3= t3 || ((next_player(state)==h) && (g!=:nothing) && (f==g) && (h!=g) && (d==:nothing) && (e==:nothing) && (b==:nothing));

    t4=((next_player(state)==h) && (e!=:nothing) && (c==e) && (h!=e) && (b==:nothing) && (d==:nothing) && (g==:nothing));

    t4= t4 || ((next_player(state)==c) && (e!=:nothing) && (h==e) && (c!=e) && (b==:nothing) && (d==:nothing) && (g==:nothing));


    T4=(t1 || t2 || t3 || t4);

        return (T1 || T2 || T3 || T4);

end



function cut1_pattern(state::GameState,point::Tuple{Int64,Int64})

    row=point[1];
    col=point[2];

    for p in area(point)
        if !(is_on_grid(state.board,p))
            return false;
        end
    end

    a=get_stone(state.board,(row+1,col-1));
    b=get_stone(state.board,(row+1,col));
    c=get_stone(state.board,(row+1,col+1));
    d=get_stone(state.board,(row,col-1));
    e=get_stone(state.board,(row,col+1));
    f=get_stone(state.board,(row-1,col-1));
    g=get_stone(state.board,(row-1,col));
    h=get_stone(state.board,(row-1,col+1));



    t1=((a!=:nothing) && (b!=:nothing) && (a!=b) && (b==d)  &&  !((e==b) && (g==:nothing))  &&  !((g==b) && (e==:nothing)));

    t2=((c!=:nothing) && (b!=:nothing) && (c!=b) && (b==e)  &&  !((d==b) && (g==:nothing))  &&  !((g==b) && (d==:nothing)));

    t3=((f!=:nothing) && (d!=:nothing) && (f!=d) && (d==g)  &&  !((d==b) && (e==:nothing))  &&  !((e==d) && (b==:nothing)));

    t4=((h!=:nothing) && (g!=:nothing) && (h!=g) && (e==g)  &&  !((d==g) && (b==:nothing))  &&  !((b==g) && (d==:nothing)));

    return (t1 || t2 || t3 || t4);

end




function cut2_pattern(state::GameState,point::Tuple{Int64,Int64})

    row=point[1];
    col=point[2];

    for p in area(point)
        if !(is_on_grid(state.board,p))
            return false;
        end
    end

    a=get_stone(state.board,(row+1,col-1));
    b=get_stone(state.board,(row+1,col));
    c=get_stone(state.board,(row+1,col+1));
    d=get_stone(state.board,(row,col-1));
    e=get_stone(state.board,(row,col+1));
    f=get_stone(state.board,(row-1,col-1));
    g=get_stone(state.board,(row-1,col));
    h=get_stone(state.board,(row-1,col+1));


    t1=((b!=:nothing) && (d!=:nothing) && (d==e) && (b!=d) && (f!=d) && (g!=d) && (h!=g));

    t2=((d!=:nothing) && (b!=:nothing) && (b==g) && (d!=b) && (h!=b) && (e!=b) && (c!=b));

    t3=((g!=:nothing) && (d!=:nothing) && (d==e) && (g!=d) && (a!=d) && (b!=d) && (c!=g));

    t4=((e!=:nothing) && (b!=:nothing) && (b==g) && (b!=e) && (a!=b) && (d!=b) && (f!=b));

    return (t1 || t2 || t3 || t4);

end




function boundary_pattern(state::GameState,point::Tuple{Int64,Int64})

    row=point[1];
    col=point[2];

    if ( !is_on_grid(state.board,(row-1,col-1)) && !is_on_grid(state.board,(row-1,col+1)) && is_on_grid(state.board,(row,col-1)) && is_on_grid(state.board,(row,col+1)) && is_on_grid(state.board,(row+1,col)) )

        a=get_stone(state.board,(row+1,col-1));
        b=get_stone(state.board,(row+1,col));
        c=get_stone(state.board,(row+1,col+1));
        d=get_stone(state.board,(row,col-1));
        e=get_stone(state.board,(row,col+1));


        t1=((a!=:nothing) && (d!=:nothing) && (a!=d) && (b==:nothing));
        t1= t1 || ((c!=:nothing) && (e!=:nothing) && (c!=e) && (b==:nothing));

        t2=((d!=:nothing) && (e!=:nothing) && (b==d) && (d!=e));
        t2= t2 || ((d!=:nothing) && (e!=:nothing) && (b==e) && (d!=e));

        t3=((b==next_player(state)) && (c!=:nothing) && (b!=c));

        t4=((c==next_player(state)) && (b!=:nothing) && (e==b) && (c!=b));
        t4= t4 || ((a==next_player(state)) && (b!=:nothing) && (d==b) && (a!=b));


        return (t1 || t2 || t3 || t4);

    end

    if ( !is_on_grid(state.board,(row-1,col-1)) && !is_on_grid(state.board,(row+1,col-1)) && is_on_grid(state.board,(row+1,col)) && is_on_grid(state.board,(row-1,col)) && is_on_grid(state.board,(row,col+1)) )

        d=get_stone(state.board,(row+1,col));
        a=get_stone(state.board,(row+1,col+1));
        b=get_stone(state.board,(row,col+1));
        e=get_stone(state.board,(row-1,col));
        c=get_stone(state.board,(row-1,col+1));


        t1=((a!=:nothing) && (d!=:nothing) && (a!=d) && (b==:nothing));
        t1= t1 || ((c!=:nothing) && (e!=:nothing) && (c!=e) && (b==:nothing));

        t2=((d!=:nothing) && (e!=:nothing) && (b==d) && (d!=e));
        t2= t2 || ((d!=:nothing) && (e!=:nothing) && (b==e) && (d!=e));

        t3=((b==next_player(state)) && (c!=:nothing) && (b!=c));

        t4=((c==next_player(state)) && (b!=:nothing) && (e==b) && (c!=b));
        t4= t4 || ((a==next_player(state)) && (b!=:nothing) && (d==b) && (a!=b));


        return (t1 || t2 || t3 || t4);

    end

    if ( !is_on_grid(state.board,(row+1,col+1)) && !is_on_grid(state.board,(row-1,col+1)) && is_on_grid(state.board,(row+1,col)) && is_on_grid(state.board,(row-1,col)) && is_on_grid(state.board,(row,col-1)) )

        c=get_stone(state.board,(row+1,col-1));
        e=get_stone(state.board,(row+1,col));
        b=get_stone(state.board,(row,col-1));
        a=get_stone(state.board,(row-1,col-1));
        d=get_stone(state.board,(row-1,col));


        t1=((a!=:nothing) && (d!=:nothing) && (a!=d) && (b==:nothing));
        t1= t1 || ((c!=:nothing) && (e!=:nothing) && (c!=e) && (b==:nothing));

        t2=((d!=:nothing) && (e!=:nothing) && (b==d) && (d!=e));
        t2= t2 || ((d!=:nothing) && (e!=:nothing) && (b==e) && (d!=e));

        t3=((b==next_player(state)) && (c!=:nothing) && (b!=c));

        t4=((c==next_player(state)) && (b!=:nothing) && (e==b) && (c!=b));
        t4= t4 || ((a==next_player(state)) && (b!=:nothing) && (d==b) && (a!=b));


        return (t1 || t2 || t3 || t4);

    end

    if ( !is_on_grid(state.board,(row+1,col-1)) && !is_on_grid(state.board,(row+1,col+1)) && is_on_grid(state.board,(row,col-1)) && is_on_grid(state.board,(row,col+1)) && is_on_grid(state.board,(row-1,col)) )

        d=get_stone(state.board,(row,col-1));
        e=get_stone(state.board,(row,col+1));
        a=get_stone(state.board,(row-1,col-1));
        b=get_stone(state.board,(row-1,col));
        c=get_stone(state.board,(row-1,col+1));


        t1=((a!=:nothing) && (d!=:nothing) && (a!=d) && (b==:nothing));
        t1= t1 || ((c!=:nothing) && (e!=:nothing) && (c!=e) && (b==:nothing));

        t2=((d!=:nothing) && (e!=:nothing) && (b==d) && (d!=e));
        t2= t2 || ((d!=:nothing) && (e!=:nothing) && (b==e) && (d!=e));

        t3=((b==next_player(state)) && (c!=:nothing) && (b!=c));

        t4=((c==next_player(state)) && (b!=:nothing) && (e==b) && (c!=b));
        t4= t4 || ((a==next_player(state)) && (b!=:nothing) && (d==b) && (a!=b));


        return (t1 || t2 || t3 || t4);

    end

    return false;
end







end
